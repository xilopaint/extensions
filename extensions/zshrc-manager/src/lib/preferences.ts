/**
 * Preference management for section detection patterns
 *
 * Provides utilities to read and validate user-configured section patterns
 * from Raycast preferences.
 */

import { getPreferenceValues } from "@raycast/api";

/**
 * Reads section preferences from Raycast configuration
 *
 * Uses the autogenerated ExtensionPreferences type from raycast-env.d.ts
 * which is generated from package.json preferences configuration.
 *
 * @returns Section preferences object using autogenerated type
 */
export function getSectionPrefs(): ExtensionPreferences {
  return getPreferenceValues<ExtensionPreferences>();
}

/**
 * Validates and compiles a regex pattern from user input
 *
 * @param pattern The regex pattern string from preferences
 * @param description Description for error messages
 * @returns Compiled regex or null if invalid
 */
export function compilePattern(pattern: string | undefined, description: string): RegExp | null {
  if (!pattern || pattern.trim().length === 0) {
    return null;
  }

  try {
    // Auto-anchor patterns and make them case-insensitive
    const anchoredPattern = pattern.startsWith("^") ? pattern : `^${pattern}`;
    return new RegExp(`${anchoredPattern}`, "i");
  } catch (error) {
    console.warn(`Invalid ${description} pattern: ${pattern}`, error);
    return null;
  }
}

/**
 * Validates that a regex pattern contains exactly one capture group
 *
 * @param pattern The regex pattern to validate
 * @returns True if pattern has exactly one capture group
 */
export function hasCaptureGroup(pattern: string): boolean {
  const captureGroupRegex = /\((?!\?[!=:])[^)]*\)/g;
  const matches = pattern.match(captureGroupRegex);
  return matches !== null && matches.length === 1;
}

/**
 * Gets compiled custom patterns from preferences
 *
 * @returns Object with compiled custom patterns
 */
export function getCustomPatterns(): {
  headerPattern: RegExp | null;
  startPattern: RegExp | null;
  endPattern: RegExp | null;
} {
  const prefs = getSectionPrefs();

  let headerPattern: RegExp | null = null;
  let startPattern: RegExp | null = null;
  let endPattern: RegExp | null = null;

  if (prefs["enableCustomHeaderPattern"] && prefs["customHeaderPattern"]) {
    if (hasCaptureGroup(prefs["customHeaderPattern"])) {
      headerPattern = compilePattern(prefs["customHeaderPattern"], "header");
    } else {
      console.warn("Custom header pattern must contain exactly one capture group");
    }
  }

  if (prefs["enableCustomStartEndPatterns"]) {
    if (prefs["customStartPattern"] && hasCaptureGroup(prefs["customStartPattern"])) {
      startPattern = compilePattern(prefs["customStartPattern"], "start");
    }
    if (prefs["customEndPattern"]) {
      endPattern = compilePattern(prefs["customEndPattern"], "end");
    }
  }

  return {
    headerPattern,
    startPattern,
    endPattern,
  };
}

import { SectionMarkerType } from "../types/enums";

/**
 * Default section formats for detection
 */
const DEFAULT_SECTION_FORMATS = {
  LABELED: /^(?:\s*)#\s*section\s*:\s*(.+?)\s*$/i,
  DASHED_START: /^(?:\s*)#\s*---\s*(?!End\b)(.+?)\s*---\s*#\s*$/i,
  DASHED_END: /^(?:\s*)#\s*---\s*End\s+.*---\s*#\s*$/i,
  BRACKETED: /^(?:\s*)#\s*\[\s*(.+?)\s*\]\s*$/i,
  HASH: /^(?:\s*)#\s*#\s*(.+?)\s*$/i,
  CUSTOM_START: /^(?:\s*)#\s*@start\s+(.+?)\s*$/i,
  CUSTOM_END: /^(?:\s*)#\s*@end\s+(.+?)\s*$/i,
  FUNCTION_START: /^(?:\s*)([A-Za-z_][A-Za-z0-9_]*)\s*\(\s*\)\s*\{\s*$/,
  FUNCTION_END: /^(?:\s*)\}\s*$/,
} as const;

/**
 * Section format configuration with type information
 */
export interface SectionFormatConfig {
  type: SectionMarkerType;
  regex: RegExp;
}

/**
 * Gets section formats in priority order based on user preferences
 *
 * Returns an array of section format configurations ordered by priority.
 * Custom patterns from preferences are included if enabled.
 *
 * @returns Array of section format configurations
 */
export function getSectionFormatsInOrder(): SectionFormatConfig[] {
  const prefs = getSectionPrefs();
  const customPatterns = getCustomPatterns();
  const formats: SectionFormatConfig[] = [];

  // Add custom start/end patterns first (highest priority) if enabled
  if (prefs["enableCustomStartEndPatterns"]) {
    if (customPatterns.startPattern) {
      formats.push({
        type: SectionMarkerType.CUSTOM_START,
        regex: customPatterns.startPattern,
      });
    }

    if (customPatterns.endPattern) {
      formats.push({
        type: SectionMarkerType.CUSTOM_END,
        regex: customPatterns.endPattern,
      });
    }
  }

  // Add default patterns if enabled
  // Skip default CUSTOM_START and CUSTOM_END if custom patterns are enabled
  // to avoid duplicate types (custom patterns are already checked first)
  if (prefs["enableDefaults"]) {
    const defaultPatterns: SectionFormatConfig[] = [
      {
        type: SectionMarkerType.DASHED_END,
        regex: DEFAULT_SECTION_FORMATS.DASHED_END,
      },
      {
        type: SectionMarkerType.DASHED_START,
        regex: DEFAULT_SECTION_FORMATS.DASHED_START,
      },
      {
        type: SectionMarkerType.BRACKETED,
        regex: DEFAULT_SECTION_FORMATS.BRACKETED,
      },
      {
        type: SectionMarkerType.HASH,
        regex: DEFAULT_SECTION_FORMATS.HASH,
      },
      {
        type: SectionMarkerType.FUNCTION_START,
        regex: DEFAULT_SECTION_FORMATS.FUNCTION_START,
      },
      {
        type: SectionMarkerType.FUNCTION_END,
        regex: DEFAULT_SECTION_FORMATS.FUNCTION_END,
      },
      {
        type: SectionMarkerType.LABELED,
        regex: DEFAULT_SECTION_FORMATS.LABELED,
      },
    ];

    // Only add default CUSTOM_START/CUSTOM_END if custom patterns are not enabled
    // or if custom patterns are enabled but no actual patterns were provided
    const hasCustomPatterns =
      prefs["enableCustomStartEndPatterns"] && (customPatterns.startPattern || customPatterns.endPattern);
    if (!hasCustomPatterns) {
      defaultPatterns.unshift(
        {
          type: SectionMarkerType.CUSTOM_START,
          regex: DEFAULT_SECTION_FORMATS.CUSTOM_START,
        },
        {
          type: SectionMarkerType.CUSTOM_END,
          regex: DEFAULT_SECTION_FORMATS.CUSTOM_END,
        },
      );
    }

    formats.push(...defaultPatterns);
  }

  // Add custom header pattern if enabled
  if (prefs["enableCustomHeaderPattern"] && customPatterns.headerPattern) {
    formats.push({
      type: SectionMarkerType.LABELED,
      regex: customPatterns.headerPattern,
    });
  }

  return formats;
}
